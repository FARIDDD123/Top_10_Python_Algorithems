**10 الگوریتم پرکاربرد پایتون** 

---

### **۱. جستجوی خطی (Linear Search)**
**توضیح:**  
جستجوی خطی یکی از ساده‌ترین الگوریتم‌های جستجو است که با بررسی تک‌تک عناصر یک لیست، عنصر مورد نظر را پیدا می‌کند. این الگوریتم زمانی کاربردی است که لیست مرتب‌نشده باشد یا اندازه لیست کوچک باشد.  
**کاربرد:**  
- جستجو در لیست‌های کوچک  
- پروژه‌های آموزشی  

---

### **۲. جستجوی دودویی (Binary Search)**
**توضیح:**  
جستجوی دودویی یک الگوریتم کارآمد برای جستجو در لیست‌های مرتب‌شده است. این الگوریتم با تقسیم لیست به دو قسمت و مقایسه مقدار هدف با عنصر وسط، به سرعت به نتیجه می‌رسد.  
**کاربرد:**  
- جستجو در دیتابیس‌های مرتب‌شده  
- پیاده‌سازی سیستم‌های جستجوی سریع  

---

### **۳. مرتب‌سازی سریع (Quick Sort)**
**توضیح:**  
مرتب‌سازی سریع یک الگوریتم مرتب‌سازی بازگشتی است که لیست را به دو قسمت تقسیم می‌کند و هر قسمت را به طور جداگانه مرتب می‌کند. این الگوریتم به دلیل سرعت بالا در لیست‌های بزرگ بسیار محبوب است.  
**کاربرد:**  
- مرتب‌سازی داده‌های بزرگ  
- پیاده‌سازی سیستم‌های مدیریت داده  

---

### **۴. مرتب‌سازی ادغامی (Merge Sort)**
**توضیح:**  
مرتب‌سازی ادغامی یک الگوریتم مرتب‌سازی تقسیم‌وحل است که لیست را به زیرلیست‌های کوچک‌تر تقسیم می‌کند و سپس آن‌ها را با هم ادغام می‌کند. این الگوریتم پایدار و کارآمد است.  
**کاربرد:**  
- مرتب‌سازی لیست‌های پیوندی  
- پردازش داده‌های حجیم  

---

### **۵. الگوریتم دایجسترا (Dijkstra's Algorithm)**
**توضیح:**  
الگوریتم دایجسترا برای پیدا کردن کوتاه‌ترین مسیر از یک گره شروع به تمام گره‌های دیگر در یک گراف وزن‌دار استفاده می‌شود. این الگوریتم در شبکه‌ها و نقشه‌ها کاربرد دارد.  
**کاربرد:**  
- مسیریابی در نقشه‌ها (مانند GPS)  
- شبکه‌های کامپیوتری  

---

### **۶. الگوریتم پریم (Prim's Algorithm)**
**توضیح:**  
الگوریتم پریم برای پیدا کردن درخت پوشای کمینه (Minimum Spanning Tree) در یک گراف وزن‌دار استفاده می‌شود. این الگوریتم از یک گره شروع می‌کند و گره‌های دیگر را به تدریج به درخت اضافه می‌کند.  
**کاربرد:**  
- طراحی شبکه‌های ارتباطی  
- بهینه‌سازی مصرف منابع  

---

### **۷. الگوریتم کروسکال (Kruskal's Algorithm)**
**توضیح:**  
الگوریتم کروسکال نیز برای پیدا کردن درخت پوشای کمینه استفاده می‌شود، اما با رویکردی متفاوت. این الگوریتم یال‌ها را بر اساس وزن مرتب می‌کند و به ترتیب آن‌ها را به درخت اضافه می‌کند.  
**کاربرد:**  
- طراحی شبکه‌های برق و آب  
- بهینه‌سازی هزینه‌ها  

---

### **۸. الگوریتم بلمن-فورد (Bellman-Ford Algorithm)**
**توضیح:**  
الگوریتم بلمن-فورد برای پیدا کردن کوتاه‌ترین مسیر در گراف‌هایی که ممکن است شامل یال‌های منفی باشند، استفاده می‌شود. این الگوریتم از الگوریتم دایجسترا قوی‌تر است، اما کندتر است.  
**کاربرد:**  
- شبکه‌های مالی  
- تحلیل گراف‌های پیچیده  

---

### **۹. الگوریتم K-Means**
**توضیح:**  
الگوریتم K-Means یک الگوریتم خوشه‌بندی (Clustering) است که داده‌ها را به K خوشه تقسیم می‌کند. این الگوریتم بر اساس فاصله نقاط از مرکز خوشه‌ها عمل می‌کند.  
**کاربرد:**  
- دسته‌بندی داده‌ها  
- پردازش تصویر  

---

### **۱۰. الگوریتم A* (A-Star)**
**توضیح:**  
الگوریتم A* یک الگوریتم جستجوی هوشمند است که برای پیدا کردن کوتاه‌ترین مسیر در گراف‌ها استفاده می‌شود. این الگوریتم از تابع هیوریستیک (Heuristic) برای بهینه‌سازی جستجو استفاده می‌کند.  
**کاربرد:**  
- مسیریابی در بازی‌های کامپیوتری  
- نقشه‌های دیجیتال  

---


در ادامه، برای هر یک از **10 الگوریتم پرکاربرد پایتون**، یک مثال کد ساده و کاربردی آورده شده است. 

---

### **۱. جستجوی خطی (Linear Search)**
```python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return f"عدد {target} در موقعیت {i} پیدا شد."
    return f"عدد {target} در لیست وجود ندارد."

# مثال استفاده
numbers = [5, 3, 8, 6, 7]
result = linear_search(numbers, 6)
print(result)
```
**توضیح:**  
این کد عدد `6` را در لیست `[5, 3, 8, 6, 7]` جستجو می‌کند و موقعیت آن را برمی‌گرداند.

---

### **۲. جستجوی دودویی (Binary Search)**
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return f"عدد {target} در موقعیت {mid} پیدا شد."
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return f"عدد {target} در لیست وجود ندارد."

# مثال استفاده
numbers = [1, 3, 5, 7, 9, 11, 13]
result = binary_search(numbers, 7)
print(result)
```
**توضیح:**  
این کد عدد `7` را در لیست مرتب‌شده `[1, 3, 5, 7, 9, 11, 13]` جستجو می‌کند.

---

### **۳. مرتب‌سازی سریع (Quick Sort)**
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# مثال استفاده
numbers = [3, 6, 8, 10, 1, 2, 1]
sorted_numbers = quick_sort(numbers)
print(sorted_numbers)
```
**توضیح:**  
این کد لیست `[3, 6, 8, 10, 1, 2, 1]` را با استفاده از مرتب‌سازی سریع مرتب می‌کند.

---

### **۴. مرتب‌سازی ادغامی (Merge Sort)**
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# مثال استفاده
numbers = [38, 27, 43, 3, 9, 82, 10]
sorted_numbers = merge_sort(numbers)
print(sorted_numbers)
```
**توضیح:**  
این کد لیست `[38, 27, 43, 3, 9, 82, 10]` را با استفاده از مرتب‌سازی ادغامی مرتب می‌کند.

---

### **۵. الگوریتم دایجسترا (Dijkstra's Algorithm)**
```python
import heapq

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]
    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        if current_distance > distances[current_node]:
            continue
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    return distances

# مثال استفاده
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}
result = dijkstra(graph, 'A')
print(result)
```
**توضیح:**  
این کد کوتاه‌ترین مسیر از گره `'A'` به تمام گره‌های دیگر در گراف را محاسبه می‌کند.

---

### **۶. الگوریتم پریم (Prim's Algorithm)**
```python
import heapq

def prim(graph, start):
    mst = []
    visited = set([start])
    edges = [(weight, start, neighbor) for neighbor, weight in graph[start].items()]
    heapq.heapify(edges)
    while edges:
        weight, u, v = heapq.heappop(edges)
        if v not in visited:
            visited.add(v)
            mst.append((u, v, weight))
            for neighbor, weight in graph[v].items():
                if neighbor not in visited:
                    heapq.heappush(edges, (weight, v, neighbor))
    return mst

# مثال استفاده
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}
result = prim(graph, 'A')
print(result)
```
**توضیح:**  
این کد درخت پوشای کمینه (Minimum Spanning Tree) گراف را با استفاده از الگوریتم پریم پیدا می‌کند.

---

### **۷. الگوریتم کروسکال (Kruskal's Algorithm)**
```python
def kruskal(graph):
    edges = sorted([(weight, u, v) for u in graph for v, weight in graph[u].items()])
    parent = {node: node for node in graph}
    mst = []

    def find(node):
        if parent[node] != node:
            parent[node] = find(parent[node])
        return parent[node]

    for weight, u, v in edges:
        root_u = find(u)
        root_v = find(v)
        if root_u != root_v:
            mst.append((u, v, weight))
            parent[root_v] = root_u
    return mst

# مثال استفاده
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}
result = kruskal(graph)
print(result)
```
**توضیح:**  
این کد درخت پوشای کمینه گراف را با استفاده از الگوریتم کروسکال پیدا می‌کند.

---

### **۸. الگوریتم بلمن-فورد (Bellman-Ford Algorithm)**
```python
def bellman_ford(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    for _ in range(len(graph) - 1):
        for u in graph:
            for v, weight in graph[u].items():
                if distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight
    return distances

# مثال استفاده
graph = {
    'A': {'B': -1, 'C': 4},
    'B': {'C': 3, 'D': 2, 'E': 2},
    'C': {},
    'D': {'B': 1, 'C': 5},
    'E': {'D': -3}
}
result = bellman_ford(graph, 'A')
print(result)
```
**توضیح:**  
این کد کوتاه‌ترین مسیر از گره `'A'` به تمام گره‌های دیگر در گراف را محاسبه می‌کند.

---

### **۹. الگوریتم K-Means**
```python
from sklearn.cluster import KMeans
import numpy as np

# داده‌ها
data = np.array([[1, 2], [1, 4], [1, 0], [4, 2], [4, 4], [4, 0]])

# خوشه‌بندی
kmeans = KMeans(n_clusters=2, random_state=0).fit(data)
labels = kmeans.labels_
centers = kmeans.cluster_centers_

print("برچسب‌ها:", labels)
print("مراکز خوشه‌ها:", centers)
```
**توضیح:**  
این کد داده‌ها را به دو خوشه تقسیم می‌کند و مراکز خوشه‌ها را برمی‌گرداند.

---

### **۱۰. الگوریتم A* (A-Star)**
```python
import heapq

def a_star(graph, start, goal):
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {node: float('inf') for node in graph}
    g_score[start] = 0
    f_score = {node: float('inf') for node in graph}
    f_score[start] = heuristic(start, goal)

    while open_set:
        _, current = heapq.heappop(open_set)
        if current == goal:
            return reconstruct_path(came_from, current)
        for neighbor, weight in graph[current].items():
            tentative_g_score = g_score[current] + weight
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
                heapq.heappush(open_set, (f_score[neighbor], neighbor))
    return None

def heuristic(a, b):
    return abs(ord(a) - ord(b))

def reconstruct_path(came_from, current):
    path = [current]
    while current in came_from:
        current = came_from[current]
        path.append(current)
    return path[::-1]

# مثال استفاده
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}
result = a_star(graph, 'A', 'D')
print(result)
```
**توضیح:**  
این کد کوتاه‌ترین مسیر از گره `'A'` به گره `'D'` را با استفاده از الگوریتم A* پیدا می‌کند.

---


